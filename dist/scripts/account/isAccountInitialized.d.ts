export declare const isAccountInitialized = "import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport NonFungibleToken from 0xNonFungibleToken\nimport Moments from 0xMoments\nimport Elvn from 0xElvn\n\npub fun hasFUSD(_ address: Address): Bool {\n  let receiver: Bool = getAccount(address)\n    .getCapability<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver)\n    .check()\n\n  let balance: Bool = getAccount(address)\n    .getCapability<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance)\n    .check()\n\n  return receiver && balance\n}\n\npub fun hasElvn(_ address: Address): Bool {\n  let receiver: Bool = getAccount(address)\n    .getCapability<&Elvn.Vault{FungibleToken.Receiver}>(/public/elvnReceiver)\n    .check()\n\n  let balance: Bool = getAccount(address)\n    .getCapability<&Elvn.Vault{FungibleToken.Balance}>(/public/elvnBalance)\n    .check()\n\n  return receiver && balance\n}\n\npub fun hasItems(_ address: Address): Bool {\n  return getAccount(address)\n    .getCapability<&Moments.Collection{NonFungibleToken.CollectionPublic, Moments.MomentsCollectionPublic}>(Moments.CollectionPublicPath)\n    .check()\n}\n\npub fun main(address: Address): {String: Bool} {\n  let ret: {String: Bool} = {}\n  ret[\"FUSD\"] = hasFUSD(address)\n  ret[\"Moments\"] = hasItems(address)\n  ret[\"Elvn\"] = hasElvn(address)\n  return ret\n}\n";
