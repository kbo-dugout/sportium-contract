export declare const initializeAccount = "import FungibleToken from 0xstd/FungibleToken\nimport NonFungibleToken from 0xstd/NonFungibleToken\nimport FUSD from 0xstd/FUSD\n\nimport Moments from 0xsprt/Moments\nimport Elvn from 0xsprt/Elvn\nimport SprtNFTStorefront from 0xsprt/SprtNFTStorefront\nimport Pack from 0xsprt/Pack\n\nimport TeleportedSportiumToken from 0xblocto/TeleportedSportiumToken\n\npub fun setupFUSD(account: AuthAccount)  {\n  if account.borrow<&FUSD.Vault>(from: /storage/fusdVault) == nil {\n    account.save(<-FUSD.createEmptyVault(), to: /storage/fusdVault)\n\n    account.link<&FUSD.Vault{FungibleToken.Receiver}>(\n      /public/fusdReceiver,\n      target: /storage/fusdVault\n    )\n\n    account.link<&FUSD.Vault{FungibleToken.Balance}>(\n      /public/fusdBalance,\n      target: /storage/fusdVault\n    )\n  }\n}\n\npub fun setupElvn(account: AuthAccount) {\n  if account.borrow<&Elvn.Vault>(from: /storage/elvnVault) == nil {\n    account.save(<-Elvn.createEmptyVault(), to: /storage/elvnVault)\n\n    account.link<&Elvn.Vault{FungibleToken.Receiver}>(\n        /public/elvnReceiver,\n        target: /storage/elvnVault\n    )\n\n    account.link<&Elvn.Vault{FungibleToken.Balance}>(\n        /public/elvnBalance,\n        target: /storage/elvnVault\n    )\n  }\n}\n\npub fun setupMoments(account: AuthAccount) {\n  if account.borrow<&Moments.Collection>(from: Moments.CollectionStoragePath) == nil {\n      let collection <- Moments.createEmptyCollection()\n      account.save(<-collection, to: Moments.CollectionStoragePath)\n\n      account.link<&Moments.Collection{NonFungibleToken.CollectionPublic, Moments.MomentsCollectionPublic}>(Moments.CollectionPublicPath, target: Moments.CollectionStoragePath)\n  }\n}\n\npub fun setupSprtStorefront(account: AuthAccount)  {\n  if account.borrow<&SprtNFTStorefront.Storefront>(from: SprtNFTStorefront.StorefrontStoragePath) == nil {\n      let storefront <- SprtNFTStorefront.createStorefront()\n      account.save(<-storefront, to: SprtNFTStorefront.StorefrontStoragePath)\n\n      account.link<&SprtNFTStorefront.Storefront{SprtNFTStorefront.StorefrontPublic}>(SprtNFTStorefront.StorefrontPublicPath, target: SprtNFTStorefront.StorefrontStoragePath)\n  }\n\n  let storefront = account.borrow<&SprtNFTStorefront.Storefront>(from: SprtNFTStorefront.StorefrontStoragePath) ?? panic(\"unreachable\")\n  storefront.saveAddress()\n}\n\npub fun setupPack(account: AuthAccount) {\n  if account.borrow<&Pack.Collection>(from: Pack.CollectionStoragePath) == nil {\n    let collection <- Pack.createEmptyCollection()\n    account.save(<-collection, to: Pack.CollectionStoragePath)\n\n    account.link<&Pack.Collection{Pack.PackCollectionPublic}>(Pack.CollectionPublicPath, target: Pack.CollectionStoragePath)\n  }\n}\n\npub fun setupSportium(account: AuthAccount) {\n  if account.borrow<&TeleportedSportiumToken.Vault>(from: TeleportedSportiumToken.TokenStoragePath) == nil {\n    account.save(<-TeleportedSportiumToken.createEmptyVault(), to: TeleportedSportiumToken.TokenStoragePath)\n\n    account.link<&TeleportedSportiumToken.Vault{FungibleToken.Receiver}>(\n        TeleportedSportiumToken.TokenPublicReceiverPath,\n        target: TeleportedSportiumToken.TokenStoragePath \n    )\n\n    account.link<&TeleportedSportiumToken.Vault{FungibleToken.Balance}>(\n        TeleportedSportiumToken.TokenPublicBalancePath,\n        target: TeleportedSportiumToken.TokenStoragePath \n    )\n  }\n}\n\ntransaction {\n  prepare(account: AuthAccount) {\n    setupFUSD(account: account)\n    setupElvn(account: account)\n    setupMoments(account: account)\n    setupSprtStorefront(account: account)\n    setupPack(account: account)\n    setupSportium(account: account)\n  }\n}\n";
