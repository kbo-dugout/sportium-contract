export declare const initializeAccount = "import FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport FUSD from 0xFUSD\nimport Moments from 0xMoments \nimport Elvn from 0xElvn\n// import NFTStorefront from 0xNFTStorefront\n\npub fun hasFUSD(_ address: Address): Bool {\n  let receiver = getAccount(address)\n    .getCapability<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver)\n    .check()\n\n  let balance = getAccount(address)\n    .getCapability<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance)\n    .check()\n\n  return receiver && balance\n}\n\npub fun hasElvn(_ address: Address): Bool {\n  let receiver: Bool = getAccount(address)\n    .getCapability<&Elvn.Vault{FungibleToken.Receiver}>(/public/elvnReceiver)\n    .check()\n\n  let balance: Bool = getAccount(address)\n    .getCapability<&Elvn.Vault{FungibleToken.Balance}>(/public/elvnBalance)\n    .check()\n\n  return receiver && balance\n}\n\npub fun hasItems(_ address: Address): Bool {\n  return getAccount(address)\n    .getCapability<&Moments.Collection{NonFungibleToken.CollectionPublic, Moments.MomentsCollectionPublic}>(Moments.CollectionPublicPath)\n    .check()\n}\n\n// pub fun hasStorefront(_ address: Address): Bool {\n//   return getAccount(address)\n//     .getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath)\n//     .check()\n// }\n\ntransaction {\n  prepare(acct: AuthAccount) {\n    if !hasFUSD(acct.address) {\n      if acct.borrow<&FUSD.Vault>(from: /storage/fusdVault) == nil {\n        acct.save(<-FUSD.createEmptyVault(), to: /storage/fusdVault)\n      }\n      acct.unlink(/public/fusdReceiver)\n      acct.unlink(/public/fusdBalance)\n      acct.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: /storage/fusdVault)\n      acct.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: /storage/fusdVault)\n    }\n\n    if !hasElvn(acct.address) {\n      if acct.borrow<&Elvn.Vault>(from: /storage/elvnVault) == nil {\n        acct.save(<-Elvn.createEmptyVault(), to: /storage/elvnVault)\n      }\n      acct.unlink(/public/elvnReceiver)\n      acct.unlink(/public/elvnBalance)\n      acct.link<&Elvn.Vault{FungibleToken.Receiver}>(/public/elvnReceiver, target: /storage/elvnVault)\n      acct.link<&Elvn.Vault{FungibleToken.Balance}>(/public/elvnBalance, target: /storage/elvnVault)\n    }\n\n    if !hasItems(acct.address) {\n      if acct.borrow<&Moments.Collection>(from: Moments.CollectionStoragePath) == nil {\n        acct.save(<-Moments.createEmptyCollection(), to: Moments.CollectionStoragePath)\n      }\n      acct.unlink(Moments.CollectionPublicPath)\n      acct.link<&Moments.Collection{NonFungibleToken.CollectionPublic, Moments.MomentsCollectionPublic}>(Moments.CollectionPublicPath, target: Moments.CollectionStoragePath)\n    }\n\n    // if !hasStorefront(acct.address) {\n    //   if acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {\n    //     acct.save(<-NFTStorefront.createStorefront(), to: NFTStorefront.StorefrontStoragePath)\n    //   }\n    //   acct.unlink(NFTStorefront.StorefrontPublicPath)\n    //   acct.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n    // }\n  }\n}\n";
