export declare const mintAndListMoment = "import NonFungibleToken from 0xNonFungibleToken\nimport Moments from 0xMoments\nimport FungibleToken from 0xFungibleToken\nimport Elvn from 0xElvn\nimport NFTStorefront from 0xNFTStorefront\n\n// This transction uses the NFTMinter resource to mint a new NFT.\n//\n// It must be run with the account that has the minter resource\n// stored at path /storage/NFTMinter.\n\ntransaction(recipient: Address, metadata: {String: String}, saleItemPrice: UFix64) {\n\n    // local variable for storing the minter reference\n    let minter: &Moments.NFTMinter\n    let elvnReceiver: Capability<&Elvn.Vault{FungibleToken.Receiver}>\n    let momentsProvider: Capability<&Moments.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefront.Storefront\n\n    prepare(signer: AuthAccount) {\n\n        // borrow a reference to the NFTMinter resource in storage\n        self.minter = signer.borrow<&Moments.NFTMinter>(from: Moments.MinterStoragePath)\n            ?? panic(\"Could not borrow a reference to the NFT minter\")\n\n         // We need a provider capability, but one is not provided by default so we create one if needed.\n        let momentsCollectionProviderPrivatePath = /private/momentsCollectionProvider\n\n        self.elvnReceiver = signer.getCapability<&Elvn.Vault{FungibleToken.Receiver}>(/public/elvnReceiver)\n\n        assert(self.elvnReceiver.borrow() != nil, message: \"Missing or mis-typed Elvn receiver\")\n\n        if !signer.getCapability<&Moments.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(momentsCollectionProviderPrivatePath).check() {\n            signer.link<&Moments.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(momentsCollectionProviderPrivatePath, target: Moments.CollectionStoragePath)\n        }\n\n        self.momentsProvider = signer.getCapability<&Moments.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(momentsCollectionProviderPrivatePath)\n\n        assert(self.momentsProvider.borrow() != nil, message: \"Missing or mis-typed Moments.Collection provider\")\n\n        self.storefront = signer.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n    }\n\n    execute {\n        // get the public account object for the recipient\n        let recipient = getAccount(recipient)\n\n        // borrow the recipient's public NFT collection reference\n        let receiver = recipient\n            .getCapability(Moments.CollectionPublicPath)\n            .borrow<&{NonFungibleToken.CollectionPublic}>()\n            ?? panic(\"Could not get receiver reference to the NFT Collection\")\n\n        // mint the NFT and deposit it to the recipient's collection\n        let result = self.minter.mintNFT(recipient: receiver, metadata: metadata)\n\n\n        let saleCut = NFTStorefront.SaleCut(\n            receiver: self.elvnReceiver,\n            amount: saleItemPrice\n        )\n        \n        self.storefront.createListing(\n            nftProviderCapability: self.momentsProvider,\n            nftType: Type<@Moments.NFT>(),\n            nftID: Moments.totalSupply - 1,\n            salePaymentVaultType: Type<@Elvn.Vault>(),\n            saleCuts: [saleCut]\n        )\n    }\n}\n ";
