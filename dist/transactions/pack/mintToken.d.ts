export declare const mintToken = "import Pack from 0xPack\nimport Moments from 0xMoments\n\ntransaction(recipient: Address, releaseId: UInt64, packPrice: UFix64, momentTokenIds: [UInt64]) {\n    let admin: &Pack.Administrator\n    let adminMomentsCollectionRef: &Moments.Collection\n\n    let recipientCollectionRef: &Pack.Collection{Pack.PackCollectionPublic}\n\n    prepare(account: AuthAccount) {\n        self.admin = account\n            .borrow<&Pack.Administrator>(from: /storage/sportiumPackAdministrator)\n            ?? panic(\"Signer is not the pack admin\")\n        \n        self.adminMomentsCollectionRef = account\n            .borrow<&Moments.Collection>(from: Moments.CollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to the owner's collection\")\n        \n        self.recipientCollectionRef = getAccount(recipient)\n            .getCapability(Pack.CollectionPublicPath)\n            .borrow<&Pack.Collection{Pack.PackCollectionPublic}>()\n            ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        for id in momentTokenIds {\n            self.adminMomentsCollectionRef.borrowMoment(id: id) \n                ?? panic(\"Not found tokenId: \".concat(id.toString()))\n        }\n\n        let momentsList: @[Moments.NFT] <- []\n        for id in momentTokenIds {\n            let moments <- self.adminMomentsCollectionRef.withdraw(withdrawID: id) as! @Moments.NFT\n            momentsList.append(<- moments)\n        }\n\n        let packToken <- self.admin\n            .createPackToken(\n                releaseId: releaseId, \n                price: packPrice, \n                momentsMap: <- momentsList\n            )\n\n        self.recipientCollectionRef.deposit(token: <- packToken)\n    }\n}\n";
