export declare const purchaseWithMoments = "import Pack from 0xPack\nimport Moments from 0xMoments\n\ntransaction(releaseId: UInt64, packPrice: UFix64, momentsIdsGroup: [[UInt64]]) {\n    let admin: &Pack.Administrator\n\n    let packCollectionRef: &Pack.Collection\n    let momentsCollectionRef: &Moments.Collection\n\n    prepare(account: AuthAccount) {\n        self.admin = account\n            .borrow<&Pack.Administrator>(from: /storage/sportiumPackAdministrator)\n            ?? panic(\"Signer is not the pack admin\")\n        \n        self.packCollectionRef = account\n            .borrow<&Pack.Collection>(from: Pack.CollectionStoragePath)\n            ?? panic(\"Unable to borrow receiver reference\")\n\n        self.momentsCollectionRef = account\n            .borrow<&Moments.Collection>(from: Moments.CollectionStoragePath)\n            ?? panic(\"Unable to borrow moments collection ref\")\n    }\n\n    execute {\n\t\tlet momentsPerCount = momentsIdsGroup[0].length\n\t\tfor momentsIds in momentsIdsGroup {\n\t\t\tassert(momentsIds.length == momentsPerCount, message: \"Not equal moments ids length\")\n\n\t\t\tlet packToken <- self.admin\n\t\t\t\t.createPackToken(\n\t\t\t\t\treleaseId: releaseId, \n\t\t\t\t\tprice: packPrice, \n\t\t\t\t\tmomentsPerCount: UInt64(momentsPerCount)\n\t\t\t)\n\t\t\tlet momentsList: @[Moments.NFT] <- []\n        \tfor id in momentsIds {\n\t\t\t\tlet moments <- self.momentsCollectionRef.withdraw(withdrawID: id) as! @Moments.NFT\n\t\t\t\tmomentsList.append(<- moments)\n        \t}\n\t\t\tself.admin.addItem(pack: <-packToken, momentsList: <-momentsList)\n\t\t}\n\n    }\n}\n ";
