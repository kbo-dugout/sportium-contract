export declare const purchaseListing = "import FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\n\nimport Elvn from 0xElvn\nimport Moments from 0xMoments\nimport SprtNFTStorefront from 0xSprtNFTStorefront\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address) {\n\n    let paymentVault: @FungibleToken.Vault\n    let momentsCollection: &Moments.Collection{NonFungibleToken.Receiver}\n    let storefront: &SprtNFTStorefront.Storefront{SprtNFTStorefront.StorefrontPublic}\n    let listing: &SprtNFTStorefront.Listing{SprtNFTStorefront.ListingPublic}\n\n    prepare(account: AuthAccount) {\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&SprtNFTStorefront.Storefront{SprtNFTStorefront.StorefrontPublic}>(\n                SprtNFTStorefront.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n            ?? panic(\"No Listing with that ID in Storefront\")\n        \n        let price = self.listing.getDetails().salePrice\n\n        let mainElvnVault = account.borrow<&Elvn.Vault>(from: /storage/elvnVault)\n            ?? panic(\"Cannot borrow Elvn vault from account storage\")\n        \n        self.paymentVault <- mainElvnVault.withdraw(amount: price)\n\n        self.momentsCollection = account.borrow<&Moments.Collection>(from: Moments.CollectionStoragePath)\n            ?? panic(\"Not found SprtNFTStorefront.Storefront PATH: \".concat(SprtNFTStorefront.StorefrontStoragePath.toString()))\n    }\n\n    execute {\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault\n        )\n\n        self.momentsCollection.deposit(token: <-item)\n\n        self.storefront.cleanup(listingResourceID: listingResourceID)\n    }\n}\n";
